
flat in int v_flags;
flat in int v_effect_id;
in float v_mix_weight;
in vec3 v_pos;
in vec2 v_origin_offset;
in vec2 v_draw_size;
in vec2 v_texture_size;
in vec2 v_uv_min;
in vec2 v_uv_max;
in vec4 v_color;
in vec4 v_mix_color;
flat in vec3 v_normal;

in vec2 v_uv;
in vec2 v_local_uv;

out vec4 out_color;

uniform vec2 base_res;
uniform vec2 window_size;
uniform float time;
uniform vec2 player_pos;
uniform vec2 mouse;
uniform vec2 snake_pos;
uniform vec2 ball_rot;
uniform float snake_apple_time;

uniform sampler2D in_texture;
uniform sampler2D noise;

#define pi 3.1415

mat2 rot(float angle)
{
	float c = cos(-angle);
	float s = sin(-angle);
	return mat2(c, -s, s, c);
}

vec2 n22(vec2 p)
{
	vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));
	a += dot(a, a + 34.45);
	return fract(vec2(a.x * a.y, a.y * a.z));
}

float range_lerp(float val, float amin, float amax, float bmin, float bmax)
{
	float p = (val - amin) / (amax - amin);
	return bmin + (bmax - bmin) * p;
}

float sin2(float s)
{
	return sin(s) * 0.5 + 0.5;
}

vec4 pma(vec4 col)
{
	return vec4(col.rgb * col.a, col.a);
}

bool point_in_rect_topleft(vec2 point, vec2 pos, vec2 size)
{
	return point.x >= pos.x && point.x <= pos.x + size.x && point.y >= pos.y && point.y <= pos.y + size.y;
}

vec3 circle(vec2 pos, vec2 uv, float radius)
{
	vec2 ar = vec2(1.0, base_res.y / base_res.x);
	pos *= ar;
	uv *= ar;
	float d = distance(pos, uv);
	d = smoothstep(radius, 0.0, d);
	// return vec3(d * 0.1, d * 0.4, d);
	return vec3(d);
}

void main()
{
	vec4 color;

	vec4 texture_color;
	if((v_flags & 1) != 0) {
		texture_color = texture(in_texture, v_uv);
		if((v_flags & 8) != 0) {
			color = vec4(1.0, 1.0, 1.0, texture_color.r) * v_color;
		}
		else {
			color = texture_color * v_color;
		}
		color.rgb = mix(color.rgb, v_mix_color.rgb, v_mix_weight);
	}
	else {
		color = v_color;
		color.rgb = mix(color.rgb, v_mix_color.rgb, v_mix_weight);
	}

	if((v_flags & 4) != 0) {
		float d = distance(v_local_uv, vec2(0.5));
		color.a *= smoothstep(0.49, 0.45, d);
	}

	vec3 light_dir = normalize(vec3(1, -1, 2));
	float d = dot(-light_dir, v_normal);
	d = max(0.0, d);
	d = pow(d * 0.5 + 0.5, 2.0);
	vec3 diffuse_light_color = vec3(1);
	// vec3 diffuse_light_color = vec3(0.5568627450980392, 0.5176470588235294, 0.8431372549019608);
	vec3 diffuse = d * texture_color.rgb * v_color.rgb * diffuse_light_color;
	color.rgb = diffuse;
	// color.rgb += 0.1 * ambient_light_color * texture_color.rgb * v_color.rgb;
	// color.rgb += 0.25 * vec3(0.1568627450980392, 0.21176470588235294, 0.8431372549019608) * (1.0 - d) * texture_color.rgb * v_color.rgb;

	// color.rgb = v_normal * 0.5 + 0.5;
	// color.a = 1;

	color = pma(color);

	if(color.a <= 0.0) { discard; }

	out_color = color;
}
